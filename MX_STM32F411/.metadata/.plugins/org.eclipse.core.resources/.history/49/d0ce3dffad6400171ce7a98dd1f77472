
//pcd8544 nokia5110 pins
//CS          PC13
//RST         PC15
//DC          PC14
//MOSI DIN    PC3
//SCK         PB10

#include "nokia_lcd.h"

//
// PCD8551/Nokia5110 Display stuff
//
#define BLACK                       1
#define WHITE                       0
#define LCDWIDTH                    84
#define LCDHEIGHT                   48
#define PCD8544_POWERDOWN           0x04
#define PCD8544_ENTRYMODE           0x02
#define PCD8544_EXTENDEDINSTRUCTION 0x01
#define PCD8544_DISPLAYBLANK        0x0
#define PCD8544_DISPLAYNORMAL       0x4
#define PCD8544_DISPLAYALLON        0x1
#define PCD8544_DISPLAYINVERTED     0x5
#define PCD8544_FUNCTIONSET         0x20
#define PCD8544_DISPLAYCONTROL      0x08
#define PCD8544_SETYADDR            0x40
#define PCD8544_SETXADDR            0x80
#define PCD8544_SETTEMP             0x04
#define PCD8544_SETBIAS             0x10
#define PCD8544_SETVOP              0x80

//bit value
#define _BV(x) (1<<x)

static GPIO_InitTypeDef  GPIO_InitStruct;

//buffer for the LCD screen
uint8_t pcd8544_buffer[LCDWIDTH*LCDHEIGHT/8] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0,
  0, 16, 0, 0, 16, 16, 224, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128, 192,
  192, 192, 192, 96, 96, 96, 255, 252, 254, 254, 206, 204, 230, 243, 97, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  128, 192, 224, 48, 24, 12, 14, 6, 3, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
  3, 7, 31, 255, 255, 254, 252, 248, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 240, 252, 255, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 240, 252, 255, 255, 255, 255, 63, 3, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 127, 255, 248, 224,
  192, 192, 128, 128, 128, 128, 128, 128, 128, 128, 128, 192, 192, 224, 224, 240,
  248, 248, 252, 254, 127, 127, 63, 31, 15, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 7, 7, 7, 15, 15, 15,
  15, 15, 15, 15, 15, 15, 7, 7, 7, 3, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

//Font Generated by MikroElektronika GLCD Font Creator 1.2.0.0
//GLCD FontName : Courier_New
//GLCD FontSize : 18 x 23
static const unsigned char Courier_New18x23[] = {
  0x11, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x01, 0xF0, 0xFF, 0x07, 0xF8, 0xFF, 0x0F, 0x7E, 0x00, 0x3F, 0x1E, 0x00, 0x3C, 0x0F, 0x00, 0x78, 0x07, 0x00, 0x70, 0x07, 0x00, 0x70, 0x07, 0x00, 0x70, 0x07, 0x00, 0x70, 0x0F, 0x00, 0x78, 0x1E, 0x00, 0x3C, 0x7C, 0x00, 0x3F, 0xF8, 0xFF, 0x0F, 0xF0, 0xFF, 0x07, 0xC0, 0xFF, 0x01, 0x00, 0x00, 0x00,  // Code for char 0
  0x11, 0x00, 0x00, 0x70, 0x1C, 0x00, 0x70, 0x1C, 0x00, 0x70, 0x1C, 0x00, 0x70, 0x1E, 0x00, 0x70, 0x0E, 0x00, 0x70, 0x0E, 0x00, 0x70, 0xFE, 0xFF, 0x7F, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x70, 0x00, 0x00, 0x70, 0x00, 0x00, 0x70, 0x00, 0x00, 0x70, 0x00, 0x00, 0x70, 0x00, 0x00, 0x70, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00,  // Code for char 1
  0x11, 0x00, 0x00, 0x70, 0xF0, 0x00, 0x78, 0xF8, 0x00, 0x7C, 0xFC, 0x00, 0x7E, 0x1E, 0x00, 0x77, 0x0E, 0x00, 0x73, 0x0F, 0x80, 0x73, 0x07, 0xC0, 0x71, 0x07, 0xE0, 0x70, 0x07, 0xF0, 0x70, 0x07, 0x70, 0x70, 0x07, 0x38, 0x70, 0x0E, 0x1C, 0x70, 0x1E, 0x1F, 0x70, 0xFC, 0x0F, 0x78, 0xF8, 0x07, 0x78, 0xE0, 0x01, 0x70, 0x00, 0x00, 0x00,  // Code for char 2
  0x11, 0x00, 0x00, 0x18, 0x0C, 0x00, 0x38, 0x1E, 0x00, 0x38, 0x1E, 0x00, 0x78, 0x0E, 0x00, 0x70, 0x0F, 0x00, 0x70, 0x07, 0x0E, 0x70, 0x07, 0x0E, 0x70, 0x07, 0x0E, 0x70, 0x07, 0x0E, 0x70, 0x07, 0x0E, 0x70, 0x0F, 0x1F, 0x70, 0x8E, 0x3F, 0x38, 0xFE, 0x7B, 0x3C, 0xFC, 0xF1, 0x1F, 0xF0, 0xF0, 0x0F, 0x00, 0xC0, 0x07, 0x00, 0x00, 0x00,  // Code for char 3
  0x11, 0x00, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00, 0xE0, 0x03, 0x00, 0xF8, 0x03, 0x00, 0xFE, 0x03, 0x00, 0x9F, 0x03, 0xC0, 0x87, 0x03, 0xF0, 0x81, 0x73, 0x7C, 0x80, 0x73, 0x3E, 0x80, 0x73, 0x0F, 0x80, 0x73, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0x7F, 0x00, 0x80, 0x73, 0x00, 0x80, 0x73, 0x00, 0x80, 0x73, 0x00, 0x00, 0x00,  // Code for char 4
  0x11, 0x00, 0x00, 0x18, 0x00, 0x00, 0x3C, 0xFF, 0x0F, 0x3C, 0xFF, 0x1F, 0x38, 0xFF, 0x1F, 0x78, 0x07, 0x0E, 0x70, 0x07, 0x0F, 0x70, 0x07, 0x07, 0x70, 0x07, 0x07, 0x70, 0x07, 0x07, 0x70, 0x07, 0x07, 0x70, 0x07, 0x07, 0x70, 0x07, 0x0E, 0x38, 0x07, 0x1E, 0x3C, 0x07, 0xFC, 0x1F, 0x03, 0xF8, 0x0F, 0x00, 0xE0, 0x07, 0x00, 0x00, 0x00,  // Code for char 5
  0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xC0, 0xFF, 0x07, 0xE0, 0xFF, 0x1F, 0xF0, 0x79, 0x3E, 0x78, 0x3C, 0x38, 0x3C, 0x1C, 0x70, 0x1E, 0x1E, 0x70, 0x0E, 0x0E, 0x70, 0x0F, 0x0E, 0x70, 0x07, 0x0E, 0x70, 0x07, 0x0E, 0x70, 0x07, 0x1C, 0x78, 0x07, 0x3C, 0x3C, 0x0F, 0xF8, 0x3F, 0x0F, 0xF0, 0x1F, 0x06, 0xC0, 0x07,  // Code for char 6
  0x11, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x07, 0x00, 0x00, 0x07, 0x00, 0x00, 0x07, 0x00, 0x00, 0x07, 0x00, 0x70, 0x07, 0x00, 0x7E, 0x07, 0xC0, 0x7F, 0x07, 0xF0, 0x0F, 0x07, 0xFE, 0x01, 0x87, 0x7F, 0x00, 0xF7, 0x0F, 0x00, 0xFF, 0x03, 0x00, 0x7F, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char 7
  0x11, 0x00, 0x00, 0x00, 0xF0, 0xC1, 0x07, 0xF8, 0xF7, 0x1F, 0xFC, 0xFF, 0x1F, 0x1E, 0x7F, 0x3C, 0x0E, 0x3E, 0x38, 0x07, 0x3C, 0x70, 0x07, 0x1C, 0x70, 0x07, 0x1C, 0x70, 0x07, 0x1C, 0x70, 0x07, 0x1C, 0x70, 0x07, 0x3C, 0x70, 0x0E, 0x3E, 0x38, 0x1E, 0x7F, 0x3C, 0xFC, 0xFF, 0x1F, 0xF8, 0xF7, 0x1F, 0xF0, 0xC1, 0x07, 0x00, 0x00, 0x00,  // Code for char 8
  0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x03, 0x30, 0xF8, 0x0F, 0x78, 0xFC, 0x1F, 0x78, 0x1E, 0x3C, 0x70, 0x0F, 0x38, 0x70, 0x07, 0x70, 0x70, 0x07, 0x70, 0x70, 0x07, 0x70, 0x78, 0x07, 0x70, 0x38, 0x07, 0x78, 0x3C, 0x0E, 0x38, 0x1E, 0x1E, 0x3C, 0x1F, 0x3C, 0x9E, 0x0F, 0xF8, 0xFF, 0x07, 0xF0, 0xFF, 0x03, 0xC0, 0x7F, 0x00   // Code for char 9
};

//holds number to display in ascii
uint8_t d[5];

#define swap(a, b) { int16_t t = a; a = b; b = t; }

void PCD8544Write(uint8_t d) {
  uint8_t i;

  GPIOC->BSRR |= (GPIO_PIN_13<<16);   //clear cs
  //bit bang
  for (i=0; i<8; i++) {
    if (d & 0x80)                    //output bit
      GPIOC->BSRR |= GPIO_PIN_3;     //din
    else
      GPIOC->BSRR |= (GPIO_PIN_3<<16);
    d <<= 1;                         //next bit
    GPIOB->BSRR |= (GPIO_PIN_10<<16); //toggle clock
    GPIOB->BSRR |= GPIO_PIN_10;
  }
  //transmission complete
  GPIOC->BSRR |= GPIO_PIN_13;         //set cs
}

void PCD8544SendCommand(uint8_t c) {
  //clear dc
  GPIOC->BSRR |= (GPIO_PIN_14<<16);
  //send command
  PCD8544Write(c);
}

//write buffer to lcd
void PCD8544Update(void) {
  uint8_t column, max_column, p;

  max_column = LCDWIDTH - 1;
  for (p=0; p<6; p++) {
    PCD8544SendCommand(PCD8544_SETYADDR | p);
    PCD8544SendCommand(PCD8544_SETXADDR);
    GPIOC->BSRR |= GPIO_PIN_14;                //set dc
    for (column=0; column<=max_column; column++)
      PCD8544Write(pcd8544_buffer[(LCDWIDTH*p) + column]);
  }
  //no idea why this is necessary but it is to finish the last byte?
  PCD8544SendCommand(PCD8544_SETYADDR );
}

//set a single pixel
void SetPixel(int16_t x, int16_t y) {
  if ((x < 0) || (x >= LCDWIDTH) || (y < 0) || (y >= LCDHEIGHT))
    return;
  pcd8544_buffer[x + (y/8)*LCDWIDTH] |= _BV(y%8);
}

//set a single pixel
void ClearPixel(int16_t x, int16_t y) {
  if ((x < 0) || (x >= LCDWIDTH) || (y < 0) || (y >= LCDHEIGHT))
    return;
  pcd8544_buffer[x + (y/8)*LCDWIDTH] &= ~_BV(y%8);
}

//Bresenham's algorithm
void DrawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1) {
  int16_t steep, dx, dy, y_step, err;

  steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }
  if (x0 > x1) {
    swap(x0, x1);
    swap(y0, y1);
  }
  dx = x1 - x0;
  dy = abs(y1 - y0);
  err = dx/2;
  if (y0 < y1)
    y_step = 1;
  else
    y_step = -1;
  for (; x0<=x1; x0++) {
    if (steep)
      SetPixel(y0, x0);
    else
      SetPixel(x0, y0);
    err -= dy;
    if (err < 0) {
      y0 += y_step;
      err += dx;
    }
  }
}

void FillRect(int16_t x, int16_t y, int16_t w, int16_t h) {
  int16_t i;

  for (i=x; i<x + w; i++)
    DrawLine(i, y, i, y + h - 1);
}

//font data: Courier_New18x23
#define FONT_WIDTH      18
#define FONT_HEIGHT     23
#define FONT_START_CHAR 48
#define FONT_END_CHAR   57

//draw character
uint8_t DrawCharXY(uint8_t x, uint8_t y, char c) {
  uint8_t i, char_width, bytes_high = FONT_HEIGHT/8 + 1;
  uint8_t bytes_per_char = FONT_WIDTH*(FONT_HEIGHT/8+1) + 1; //+1 for width byte at start
  const unsigned char *p;

  if (c < FONT_START_CHAR || c > FONT_END_CHAR)
    c = '0';
  p = Courier_New18x23 + (c - FONT_START_CHAR)*bytes_per_char;
  //first byte of character is always width of character
  char_width = *p;
  p++;                                //step over width field
  for (i=0; i<char_width; i++) {
    uint8_t j;

    for (j=0; j<bytes_high; j++) {
      uint8_t b, dat;

      dat = *(p + i*bytes_high + j);
      for (b=0; b<8; b++) {
        if (x + i >= LCDWIDTH || y + j*8 + b >= LCDHEIGHT)
          return 0;                   //don't write past dimensions of LCD, skip entire char
        if ((j*8 + b) >= FONT_HEIGHT)  //we should not write if y bit exceeds font height
          continue;                   //skip bit
        if (dat & (1<<b))
          SetPixel(x + i, y + j*8 + b);
        else
          ClearPixel(x + i, y + j*8 + b);
      }
    }
  }
  return char_width;
}

//convert uint32_t millis value to array of 4 digits
void ExtractDigits(uint32_t number) {
  uint8_t i;

 // number /= 10;  //eliminate thousands digit
  i = 0;
  while (number > 0) {
    //pull individual digits from 'number' and stuff into 'd' array
    d[i++] = (uint8_t)(number%10) + 48;
    number /= 10;
  }
  while (i <= 4) //display needs 4 chars
    d[i++] = 48; //fill with leading '0's
}

void DisplayTime(uint32_t number) {
  ExtractDigits(number/10);    //convert UL to byte array
  DrawCharXY(1, 10, d[3]);
  DrawCharXY(21, 10, d[2]);
  DrawCharXY(46, 10, d[1]);
  DrawCharXY(66, 10, d[0]);
  //decimal point
  FillRect(41, 30, 3, 3);
}

void BigNumber(uint32_t number) {
  ExtractDigits(number);    //convert UL to byte array
  DrawCharXY(1, 10, d[3]);
  DrawCharXY(22, 10, d[2]);
  DrawCharXY(44, 10, d[1]);
  DrawCharXY(66, 10, d[0]);
}

void PCD8544SetContrast(uint8_t val) {
  if (val > 0x7f)
    val = 0x7f;
  PCD8544SendCommand(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION);
  PCD8544SendCommand(PCD8544_SETVOP | val);
  PCD8544SendCommand(PCD8544_FUNCTIONSET);
}

//clear buffer
void ClearDisplayBuffer(void) {
  memset(pcd8544_buffer, 0, LCDWIDTH*LCDHEIGHT/8);
}

void PCD8544GPIOConfig(void) {

  //cs
	  GPIO_InitStruct.Pin = GPIO_PIN_13;
	  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	  GPIO_InitStruct.Pull = GPIO_PULLUP;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  //mo
	  GPIO_InitStruct.Pin = GPIO_PIN_3;
	  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	  GPIO_InitStruct.Pull = GPIO_PULLUP;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  //dc
	  GPIO_InitStruct.Pin = GPIO_PIN_14;
	  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	  GPIO_InitStruct.Pull = GPIO_PULLUP;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  //rst
	  GPIO_InitStruct.Pin = GPIO_PIN_15;
	  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	  GPIO_InitStruct.Pull = GPIO_PULLUP;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
	  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  //sck
	  GPIO_InitStruct.Pin = GPIO_PIN_10;
	  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	  GPIO_InitStruct.Pull = GPIO_PULLUP;
	  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
	  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

void PCD8544Init(void) {
  uint32_t i;

  Start_Gpio();

  PCD8544GPIOConfig();
  GPIOC->BSRR |= GPIO_PIN_14;        //dc
  GPIOC->BSRR |= GPIO_PIN_3;        //mo
  GPIOB->BSRR |= GPIO_PIN_10;        //clock
  GPIOC->BSRR |= GPIO_PIN_13;        //cs
  GPIOC->BSRR |= (GPIO_PIN_15<<16); //rst
  //slight delay
  for (i=0;i<10000; i++)
    ;
  GPIOC->BSRR |= GPIO_PIN_15;       //rst
  //get into the EXTENDED mode
  PCD8544SendCommand(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION );
  //contrast
  PCD8544SendCommand(PCD8544_SETVOP | 0x40);
  //LCD bias select (4 is optimal?)
  PCD8544SendCommand(PCD8544_SETBIAS | 0x04);
  //normal mode
  PCD8544SendCommand(PCD8544_FUNCTIONSET);
  PCD8544SendCommand(PCD8544_DISPLAYCONTROL | PCD8544_DISPLAYNORMAL);
  //push out pcd8544_buffer to the display
  PCD8544Update();
}

void Start_Gpio(void)
{
__GPIOA_CLK_ENABLE();
__GPIOB_CLK_ENABLE();
__GPIOC_CLK_ENABLE();


GPIO_InitStruct.Pin = GPIO_PIN_5;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

GPIO_InitStruct.Pin = GPIO_PIN_13;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

}
